<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)
           
           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/

  URL:
-->

<html>
  <head>
    <title>It's React Time!</title>

    <meta charset='utf-8'>

    <!-- Main JS file from html5slides project, you should probably don't touch it -->
    <script src="resources/libs/slides.js"></script>
    <!-- jQuery - it's not required, if you don't need it - remove it -->
    <script src="resources/libs/jquery.js"></script>

    <!-- Main CSS file from html5slides project - again, don't touch this stuff -->
    <link rel="stylesheet"  href='resources/styles.css'>
    <!-- Some nice icons - check them out: http://shoestrap.org/downloads/elusive-icons-webfont/ -->
    <link rel="stylesheet" href="resources/elusive-webfont/css/elusive-webfont.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="resources/custom.css">
  </head>

  <body style='display: none'>

    <!-- This is main container, you can change presentation layout by changing layout-regular to layout-faux-widescreen or layout-widescreen.-->
    <section class='slides layout-regular'>

      <!-- Title slide -->
      <article class="title_slide">
        <h1>It's React Time</h1>
        <h2>Wprowadzenie w podstawy React</h2>

        <br />
        <br />
        <div class="title_info">
          Prowadzące:
          <br />
          Ewa Turska
          <br />
          Jadzia Przebinda
          <br />
          <span class="small">Grudzień 2019</span> 
        </div>
      </article>

      <article>
        <h3>Wymagania</h3>
        <p>Zainstalowane: <strong>node</strong> oraz <strong>npm</strong></p>
        <p>W terminalu należy wykonać: <code> npm install create-react-app </code></p>
        <br />
        <br />
        <h3>Tworzenie projektu</h3>
        <p>W terminalu należy wywołać: </p>
        <p><code>npx create-react-app <strong>nazwa-projektu</strong></code></p>
        <br />
        <br />
        <h3>Uruchomienie projektu</h3>
        <p>W terminalu po przejściu do katalogu <code><strong>nazwa-projektu</strong></code> należy wykonać:</p>
        <p><code>npm install</code></p>
        <p><code>npm start</code></p>
        <p>Projekt powinien uruchomić się pod adresem <code>http://localhost:3000</code>. Jeśli tak się nie stało, prawdopodobnie port 3000
        jest zajęty i w terminalu znajdziemy informację, pod jakim adresem jest uruchomiona aplikacja.</p>
      </article>

      <article>
        <h3>Komponenty</h3>
        <p>Każdy komponent Reactowy musi zawierać:</p>
        <pre>
          import React from "react";        </pre>
        <p>Zazwyczaj "główny" plik JS-owy to index.js, który wygląda w ogólnym zarysie tak:</p>
        <pre>
          import React from "react";
          import ReactDOM from 'react-dom';

          import App from './components/App';

          ReactDOM.render(
              &lt;App /&gt;,
              document.querySelector('#root')
          );        </pre>
        <p>gdzie:</p>
        <ul>
          <li><code>import ReactDOM from 'react-dom';</code> jest potrzebne tylko wtedy, gdy korzystamy z <code>ReactDOM.render()</code></li>
          <li><code>ReactDOM.render</code> jako pierwszy parametr przyjmuje nasz główny komponent <strong>App</strong>, a jako drugi identyfikator kontenera, w jakim chcemy osadzić naszą aplikację</li>
        </ul>
      </article>
      <article>
        <h3>Function based component</h3>
        <pre>
          const App = function() {
              return &lt;div&gt;Hi there!&lt;/div&gt;
          }          </pre>
        <p>lub</p>
        <pre>
          const App = () => {
              return &lt;div&gt;Hi there!&lt;/div&gt;
          }            </pre>
        <ul>
          <li>nie ma tu metody <code>render</code>, zamiast metod cyklu życia używa się tzw. "hooków"</li>
          <li><strong>state</strong> jest definiowany za pomocą hook'a <code>useState</code></li>
          <li>W <code>return ()</code> znajduje się to, co komponent ma "narysować"</li>
        </ul>
        <p><br /><br />Powyższe informacje są bardzo ogólnikowe, jako że na warsztatach uczymy się używać komponentów klasowych.</p>
      </article>
      <article>
        <h3>Class based component</h3>
        <pre>
          import React from "react";
          class App extends React.Component {
            render() {
              return &lt;div&gt;Hi there!&lt;/div&gt;
            }
          }              
          export default App;</pre>
        <pre>
          import React, {Component} from "react";
          class App extends Component {          
            render() {
              return &lt;div&gt;Hi there!&lt;/div&gt;
            }
          }
          export defauult App;</pre>
          <p>Powyższe zapisy różnią się tylko tym, jak korzystamy z <code>React.Component</code>. </p>
          <p>W komponentach klasowych metodą odpowiadającą za "rysowanie" komponentu jest <code>render()</code>. Oprócz tego mamy dostęp do metod cyklu życia (o czym później).</p>
      </article>

      <article>
        <h3>JSX</h3>
        <ul>
          <li>Pozornie wygląda bardzo znajomo jak HTML, jednak nie jest to HTML :)</li>
          <li>Przeglądarki nie rozumieją JSX - potrzebny jest Babel do kompilacji. Korzystając z <strong>create-react-app</strong> nie martwimy się tym - paczka ma już skonfigurowanego webpacka z babelem</li>
          <li>Jest wygodny w używaniu i ułatwia rozumienie/czytanie kodu</li>
          <li>Nie musicie go używać, ale jest rekomendowany</li>
          <li>zawiera komponenty, elementy (odpowiedniki tagów HTML) oraz JS-ową logikę</li>
          <li>żeby "jawnie" pokazać, że korzysta się z JSXa, używa się nawiasów okrągłych <code><strong>(</strong>&lt;div&gt;Witaj świecie!&lt;/div&gt;<strong>)</strong></code></li>
          <li>by poinformować kompilator, że w JSXie schce się skorzystać z logiki JS-owej bądź wyświetlić wartość zmiennej, należy użyć nawiasów klamrowych <code>(&lt;div&gt;Witaj <strong>{</strong>name<strong>}</strong>!&lt;/div&gt;)</code></li>
        </ul>
      </article>

      <article>
        <h3>Props</h3>
        <div style="position: relative;">
        <p class="pre-label">Plik List.js</p>
        <pre>

          class List extends React.Component {
            render() {
              return (
                &lt;div&gt;
                  &lt;p&gt;{this.props.<strong>title</strong>}}&lt;/p&gt;
                  &lt;ul className=“list”&gt; 
                    {this.props.<strong>list</strong>.map(element => &lt;li key={element.id}&gt;{element.name}}&lt;/li&gt;)}
                  &lt;/ul&gt;
                &lt;/div&gt;
              )
            }
          }
          export default List;
        </pre>
        </div>
        <div style="position: relative;">
        <p class="pre-label">Plik App.js</p>
        <pre>

          import List from "./components/List.js"
          class App extends React.Component {
            render() {
              return  (
                &lt;List <strong>title</strong>="Lista rzeczy do kupienia" <strong>list</strong>={[{id:1, name:"Przedmiot 1"}, {id:2, name:"Przedmiot 2"}]}/&gt;
              );
            }
          }              
        </pre>
        </div>
      </article>

      <article>
        <h3>Props</h3>
        <ul>
          <li><strong>Propsami</strong> nazywamy te wartości, które przekazujemy komponentowi jako atrybuty. </li>
          <li>Do wartości propsa dostajemy się poprzez <code>this.props.<strong>nazwa_atrybutu</strong></code> - tak jak na poprzednim slajdzie widzimy:
          komponent <code>List</code> dostaje tablicę jako atrybut <code>list</code> oraz tekst jako atrybut <code>title</code>. Możemy się do nich dostać
          wewnątrz komponentu poprzed odwołanie się do <code>this.props.list</code> oraz <code>this.props.title</code>.</li>
          <li>Gdy zmienią się wartości propsów (nastąpi ich aktualizacja z komponentu wyżej), React aktualizuje lub przerenderowuje komponent.</li>
          <li>Jako props możemy przekazać wartość - wtedy w komponencie używamy <code>this.props.propsName</code>, albo możemy przekazać metodę - 
          wtedy w komponencie możemy wywołać tę metodę: <code>this.props.propsName()</code>.</li>
          <li>Czasem możemy chcieć przekazać do komponentu wynik jakiejś metody, wtedy po prostu robimy: <code>propsName={this.foo()}</code>, 
          a w komponencie używamy jako <code>this.props.propsName</code>.</li>
          <li>Gdy do wyświetlania listy korzystamy z <code>map</code>, musimy pamiętać, że każdy element/komponent zwracany przez <code>map</code> musi mieć ustawiony atybut <code>key</code>.
          <code>Key</code> musi posiadać unikalną wartość - najczęściej jest to <strong>id</strong>.</li>
          <li>Nie zaleca się ustawiania jako <code>key</code> kolejnej wartości iteracji - używana tablica może być tylko posortowana inaczej, co powoduje,
          że wcześniejsze indeksy iteracji odpowiadają teraz innym elementom, przez co React przerenderuje/zaktualizuje wszystkie elementy, zamiast zaktualizować tylko te, które 
          się zmieniły.</li>
        </ul>
      </article>
      <article>
        <h3>Props - przykład</h3>
        <table>
          <tr>
            <th>Sortowanie wg ceny</th>
            <th>Sortowanie wg nazwy</th>
          </tr>
          <tr>
            <td><pre>list = [{id: 1, name: "gruszka", price: 2},
        {id: 2, name: "jabłko", price: 2},
        {id: 3, name: "banany", price: 5},
        {id: 4, name: "kaki", price: 7}]</pre></td>
            <td><pre>list = [{id: 3, name: "banany", price: 5},
        {id: 1, name: "gruszka", price: 2},
        {id: 2, name: "jabłko", price: 2},
        {id: 4, name: "kaki", price: 7}]</pre></td>
          </tr>
        </table>
        <table>
            <tr>
              <th>Id jako key</th>
              <th>Indeks iteracji jako key</th>
            </tr>
            <tr>
              <td><pre>list.map( (element) => (
    &lt;li key={element.id}&gt;name: {element.name}, price: {element.price}&lt;/li&gt
  )
)</pre></td>
              <td><pre>list.map( (element, index) => (
    &lt;li key={index}&gt;name: {element.name}, price: {element.price}&lt;/li&gt
  )
)</pre></td>
            </tr>
          </table>
          <p>React tworzy sobie tzw. <strong>Virtual DOM</strong>, 
          na podstawie którego renderuje drzewo DOM w przeglądarce. Gdy się coś zmienia to tworzy nowy Virtual DOM, porównuje go 
        z poprzednim i na podstawie różnic decyduje, które elementy w drzewie DOM powinny się zmienić i w jakim zakresie. Gdy jako key używamy np. id,
         React wie, że zmieniła się tylko kolejność komponentów, zatem jest w stanie zastosować najbardziej optymalny algorytm uaktualnienia drzewa DOM.
     Gdy korzystamy z indeksu iteracji, dla Reacta wszystkie albo prawie wszystkie komponenty/elementy (u nas <code>li</code>) się zmieniły - bo mają inne 
    identyfikatory - zatem algorytm aktualizacji komponentów i drzewa DOM zawiera dużo niepotrzebnych operacji i automatycznie jest znacznie mniej optymalny.</p>
      </article>
      
      <article>
        <h3>State</h3>
        <pre>
            class SearchBar extends React.Component {
              state = {
                  phrase: ""
              }          
              onInputChange = (event) => {
                  this.setState({
                      phrase: event.target.value
                  });
              }
              render() {
                  return (
                      &lt;form&gt;
                          &lt;label&gt;{this.props.label}&lt;/label&gt;
                          &lt;input 
                              type="text" 
                              value={this.state.phrase}
                              onChange={this.onInputChange}
                          /&gt;
                          &lt;div&gt;Result word is: {this.state.phrase}&lt;/div&gt;
                      &lt;/form&gt;
                  )
              }
          } </pre>
      </article>

      <article>
        <h3>State</h3>
        <p>State można utworzyć na dwa sposoby:</p>
        <pre>
           class SearchBar extends React.Component {
             constructor(props) {
               super(props);
               this.state = { 
                 phrase: ""
                }
             }
           }</pre>
           <p>lub:</p>
           <pre>
             class SearchBar extends React.Component {
               state = {
                 phrase: ""
               }
             }
           </pre>
        <p>Używając konstruktora obowiązkowym jest przekazanie mu <code>props</code> i w pierwszej linii ciała konstruktora wywołanie 
        <code>super(props)</code>. Dzięki temu nie "zgubimy" propsów komponentu-rodzica i będziemy mogli z nich korzystać (o ile jakieś są).</p>
      </article>

      <article>
        <h3>State</h3>
        <p>W stanie możemy przechowywać dowolne struktury:</p>
        <pre>
          state = {
            title: "To jest tytuł",
            list: [ "jabłko", "gruszka", "banan" ],
            counter: 5,
            pagination: {
              page: 1,
              total: 24,
              offset: 10
            },
            checked: true
          }</pre>
          <p>Gdy chcemy zaktualizować stan, używamy <code>this.setState():</code></p>
          <pre>
            this.setState({
              checked: false,
              title: "To jest fajny tytuł"
            });</pre>
      </article>

      <article>
        <h3>State</h3>
        <ul>
          <li><strong>State</strong> jest obiektem przechowującym wartości stanu komponentu.</li>
          <li>Zmiana stanu komponentu (użycie <code>this.setState()</code>) informuje Reacta, że należy przerenderować komponent.</li>
          <li>używając <code>setState()</code> ustawiamy nową wartość tylko dla tej składowej, która nas interesuje - pozostałe składowe pomijamy. 
            Nie musimy przepisywać całej zawartości obiektu stanu - React samodzielnie dba o zachowanie wszystkich innych składowych stanu.</li>
          <li><strong>Nie wolno</strong> wywoływać <code>this.setState()</code> w metodzie <code>render()</code> komponentu! W konsoli zobaczymy 
            informację o niedozwolonej operacji. Pamiętajcie, że zmiana stanu powoduje przerenderowanie komponentu, czyli wywołanie metody <code>render()</code>.</li>
          <li>W stanie trzymamy tylko to, co jest nam koniecznie potrzebne do prawidłowego działania komponentu i jednocześnie powinno być zmieniane tylko 
            w obrębie tego komponentu, np:
            <ul>
              <li>dane pobrane z API,</li>
              <li>wartości inputów,</li>
              <li>stany checkboxów i radio buttonów (selected: true/false),</li>
              <li>stan pobierania danych (isLoading: true/false, isLoaded: true/false),</li>
              <li>listy, które są w tym komponencie sortowane</li>
            </ul>
          </li>
        </ul>
      </article>

      <article>
        <h3>Renderowanie komponentów</h3>
        <pre>
          class App extends React.Component {
            <strong>state = {
              priority: "Bardzo ważne"  
            }</strong>
            <strong>getDescription()</strong> = () => {
              return ‘Lista zakupów na dzisiejszą kolację’;
            }
            render() {
              return ( 
                &lt;div style=<strong>{{marginTop:</strong> 20px;<strong>}}</strong>&gt;
                  &lt;p&gt;<strong>{this.state.priority}</strong> : <strong>{this.getDescription()}</strong>&lt;/p&gt;
                  &lt;ul <strong>className</strong>="list"&gt;
                    &lt;li&gt;{<strong>this.props</strong>.list[0].name}&lt;/li&gt;
                    &lt;li&gt;{<strong>this.props</strong>.list[1].name}&lt;/li&gt;
                  &lt;/ul&gt;
                &lt;/div&gt;
              )
            }
          }</pre>
      </article>

      <article>
        <h3>Renderowanie komponentów</h3>
        <ul>
          <li>Gdy osadzamy style inline, zawsze zewnętrzne nawiasy klamrowe informują Reacta, że będziemy "korzystać z JSa", 
            zaś wewnętrzne nawiasy klamrowe tworzą obiekt, w którym definiujemy pary <code>nazwaWłasności : wartość</code> oddzielone od siebie przecinkiem.</li>
          <li>W stylach inline wszystkie własności piszemy używając notacji camelCase.</li>
          <li>Chcąc nadać elementowi HTMLowemu klasę używamy atrybutu <code>className</code>, gdyż <code>class</code> jest w JavaScripcie słowem zarezerwowanym.</li>
          <li>By wyświetlić prostą wartość propsa, odwołujemy się do niego w nawiasach klamrowych poprzez <code>this.props.propsName</code>.</li>
          <li>By wyświetlić prostą wartość stanu (state), odwołujemy się do niego w nawiasach klamrowych poprzez <code>this.state.stateName</code>.</li>
          <li>Aby wyświetlić wynik działania metody komponentu, należy ją wywołać w nawiasach klamrowych: <code>this.methodName()</code>.</li>
          <li>By wykonać pewną logikę JavaScriptową w JSXie, należy ją osadzić w nawiasach klamrowych, na przykład:
            <pre>{ this.state.isLoading ? &lt;Loader /&gt; : &lt;List /&gt; }</pre>
          </li>
        </ul>
      </article>

      <article>
        <h3>Life cycle methods</h3>
        <p>Komponent w React może być w 3 stanach:</p>
        <ul>
          <li>Montowania - komponent jest dodany do drzewa DOM i wywoływane są metody:
            <ul>
              <li>constructor()</li>
              <li>getDerivedStateFromProps()</li>
              <li>render()</li>
              <li>componentDidMount()</li>
            </ul>
          </li>
          <li>Aktualizacji - zmiana właściwości (props) powoduje, że komponent powinien się przerenderować i wywoływane są metody:
            <ul>
              <li>getDerivedStateFromProps()</li>
              <li>shouldComponentUpdate()</li>
              <li>render()</li>
              <li>getSnapshotBeforeUpdate()</li>
              <li>componentDidUpdate()</li>
            </ul>
          </li>
          <li>Odmontowywania - komponent jest usuwany z drzewa DOM i wywoływana jest metoda:
            <ul>
              <li>componentWillUnmount()</li>
            </ul>
          </li>
        </ul>
        <p>Więcej informacji o metodach cyklu życia komponentu <a href="https://pl.reactjs.org/docs/react-component.html">tutaj</a>.</p>
      </article>
    </section>

    <script>
        (function() {
            //makes all links open in a separate tab/window
            var allLinks = document.querySelectorAll('body a');
            for(var i= 0, l=allLinks.length; i<l; i++){
                allLinks.item(i).setAttribute('target', '_blank');
            }
        })();
    </script>
  </body>
</html>